// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'catch.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CatchData _$CatchDataFromJson(Map<String, dynamic> json) {
  return _CatchData.fromJson(json);
}

/// @nodoc
mixin _$CatchData {
  String? get id => throw _privateConstructorUsedError;
  String get species => throw _privateConstructorUsedError;
  double get weight => throw _privateConstructorUsedError;
  double get length => throw _privateConstructorUsedError;
  String get spotId => throw _privateConstructorUsedError;
  String get notes => throw _privateConstructorUsedError;
  String get weather => throw _privateConstructorUsedError;
  double get temperature => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  @LatLngConverter()
  LatLng get location => throw _privateConstructorUsedError;
  List<String> get photos => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CatchDataCopyWith<CatchData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CatchDataCopyWith<$Res> {
  factory $CatchDataCopyWith(CatchData value, $Res Function(CatchData) then) =
      _$CatchDataCopyWithImpl<$Res, CatchData>;
  @useResult
  $Res call(
      {String? id,
      String species,
      double weight,
      double length,
      String spotId,
      String notes,
      String weather,
      double temperature,
      DateTime timestamp,
      @LatLngConverter() LatLng location,
      List<String> photos,
      Map<String, dynamic> metadata});
}

/// @nodoc
class _$CatchDataCopyWithImpl<$Res, $Val extends CatchData>
    implements $CatchDataCopyWith<$Res> {
  _$CatchDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? species = null,
    Object? weight = null,
    Object? length = null,
    Object? spotId = null,
    Object? notes = null,
    Object? weather = null,
    Object? temperature = null,
    Object? timestamp = null,
    Object? location = null,
    Object? photos = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      species: null == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as String,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double,
      spotId: null == spotId
          ? _value.spotId
          : spotId // ignore: cast_nullable_to_non_nullable
              as String,
      notes: null == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String,
      weather: null == weather
          ? _value.weather
          : weather // ignore: cast_nullable_to_non_nullable
              as String,
      temperature: null == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as LatLng,
      photos: null == photos
          ? _value.photos
          : photos // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CatchDataImplCopyWith<$Res>
    implements $CatchDataCopyWith<$Res> {
  factory _$$CatchDataImplCopyWith(
          _$CatchDataImpl value, $Res Function(_$CatchDataImpl) then) =
      __$$CatchDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String species,
      double weight,
      double length,
      String spotId,
      String notes,
      String weather,
      double temperature,
      DateTime timestamp,
      @LatLngConverter() LatLng location,
      List<String> photos,
      Map<String, dynamic> metadata});
}

/// @nodoc
class __$$CatchDataImplCopyWithImpl<$Res>
    extends _$CatchDataCopyWithImpl<$Res, _$CatchDataImpl>
    implements _$$CatchDataImplCopyWith<$Res> {
  __$$CatchDataImplCopyWithImpl(
      _$CatchDataImpl _value, $Res Function(_$CatchDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? species = null,
    Object? weight = null,
    Object? length = null,
    Object? spotId = null,
    Object? notes = null,
    Object? weather = null,
    Object? temperature = null,
    Object? timestamp = null,
    Object? location = null,
    Object? photos = null,
    Object? metadata = null,
  }) {
    return _then(_$CatchDataImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      species: null == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as String,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as double,
      spotId: null == spotId
          ? _value.spotId
          : spotId // ignore: cast_nullable_to_non_nullable
              as String,
      notes: null == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String,
      weather: null == weather
          ? _value.weather
          : weather // ignore: cast_nullable_to_non_nullable
              as String,
      temperature: null == temperature
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as double,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as LatLng,
      photos: null == photos
          ? _value._photos
          : photos // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CatchDataImpl implements _CatchData {
  const _$CatchDataImpl(
      {this.id,
      required this.species,
      required this.weight,
      required this.length,
      required this.spotId,
      this.notes = '',
      required this.weather,
      required this.temperature,
      required this.timestamp,
      @LatLngConverter() required this.location,
      final List<String> photos = const [],
      final Map<String, dynamic> metadata = const {}})
      : _photos = photos,
        _metadata = metadata;

  factory _$CatchDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$CatchDataImplFromJson(json);

  @override
  final String? id;
  @override
  final String species;
  @override
  final double weight;
  @override
  final double length;
  @override
  final String spotId;
  @override
  @JsonKey()
  final String notes;
  @override
  final String weather;
  @override
  final double temperature;
  @override
  final DateTime timestamp;
  @override
  @LatLngConverter()
  final LatLng location;
  final List<String> _photos;
  @override
  @JsonKey()
  List<String> get photos {
    if (_photos is EqualUnmodifiableListView) return _photos;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_photos);
  }

  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'CatchData(id: $id, species: $species, weight: $weight, length: $length, spotId: $spotId, notes: $notes, weather: $weather, temperature: $temperature, timestamp: $timestamp, location: $location, photos: $photos, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CatchDataImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.species, species) || other.species == species) &&
            (identical(other.weight, weight) || other.weight == weight) &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.spotId, spotId) || other.spotId == spotId) &&
            (identical(other.notes, notes) || other.notes == notes) &&
            (identical(other.weather, weather) || other.weather == weather) &&
            (identical(other.temperature, temperature) ||
                other.temperature == temperature) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.location, location) ||
                other.location == location) &&
            const DeepCollectionEquality().equals(other._photos, _photos) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      species,
      weight,
      length,
      spotId,
      notes,
      weather,
      temperature,
      timestamp,
      location,
      const DeepCollectionEquality().hash(_photos),
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CatchDataImplCopyWith<_$CatchDataImpl> get copyWith =>
      __$$CatchDataImplCopyWithImpl<_$CatchDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CatchDataImplToJson(
      this,
    );
  }
}

abstract class _CatchData implements CatchData {
  const factory _CatchData(
      {final String? id,
      required final String species,
      required final double weight,
      required final double length,
      required final String spotId,
      final String notes,
      required final String weather,
      required final double temperature,
      required final DateTime timestamp,
      @LatLngConverter() required final LatLng location,
      final List<String> photos,
      final Map<String, dynamic> metadata}) = _$CatchDataImpl;

  factory _CatchData.fromJson(Map<String, dynamic> json) =
      _$CatchDataImpl.fromJson;

  @override
  String? get id;
  @override
  String get species;
  @override
  double get weight;
  @override
  double get length;
  @override
  String get spotId;
  @override
  String get notes;
  @override
  String get weather;
  @override
  double get temperature;
  @override
  DateTime get timestamp;
  @override
  @LatLngConverter()
  LatLng get location;
  @override
  List<String> get photos;
  @override
  Map<String, dynamic> get metadata;
  @override
  @JsonKey(ignore: true)
  _$$CatchDataImplCopyWith<_$CatchDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
